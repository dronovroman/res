<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Name Bunny Blaster: Fur-midable Fun</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #333; color: white; cursor: none; } /* Hide default cursor */
        canvas { display: block; }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            cursor: default; /* Show cursor on overlays */
        }
        .overlay-content {
            background-color: rgba(50, 50, 50, 0.9);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .overlay h1 { margin-top: 0; }
        .overlay input[type="text"] {
            display: block;
            margin: 10px auto;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            width: 200px;
        }
        .overlay button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }
        .overlay button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }
        #start-screen ul { list-style: none; padding: 0; }
        #end-screen ul { list-style: decimal; padding-left: 40px; text-align: left;}
        #end-screen li { margin-bottom: 5px; }

        #crosshair {
            position: fixed;
            width: 22px; /* Crosshair size */
            height: 22px;
            background: transparent;
            box-sizing: border-box; 
            pointer-events: none;
            mix-blend-mode: difference;
            z-index: 20;
            display: none; /* Hidden initially */
            transform: translate(-50%, -50%); /* Center the crosshair on cursor */
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: white; 
        }
        #crosshair::before { /* Vertical line */
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after { /* Horizontal line */
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #name-notification {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            background: rgba(20, 100, 20, 0.8);
            color: white;
            font-size: 28px;
            font-weight: bold;
            border-radius: 8px;
            display: none;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="start-screen" class="overlay">
        <div class="overlay-content">
            <h1>Name Bunny Blaster</h1>
            <p>Enter 5 names:</p>
            <ul>
                <li><input type="text" id="name1" placeholder="Name 1"></li>
                <li><input type="text" id="name2" placeholder="Name 2"></li>
                <li><input type="text" id="name3" placeholder="Name 3"></li>
                <li><input type="text" id="name4" placeholder="Name 4"></li>
                <li><input type="text" id="name5" placeholder="Name 5"></li>
            </ul>
            <button id="start-game-btn" disabled>Start Game</button>
        </div>
    </div>

    <div id="gameplay-ui">
        <div id="crosshair"></div>
        <div id="name-notification"></div>
    </div>

    <div id="end-screen" class="overlay" style="display: none;">
        <div class="overlay-content">
            <h1>Success! <br>
			You've officially run out of friends <br>(to name, in this game)</h1>
            <p>Names in order of appearance:</p>
            <ul id="shot-names-list"></ul>
            <button id="restart-game-btn">Restart Game</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        // Game State
        const GameState = {
            START_SCREEN: 'START_SCREEN',
            PLAYING: 'PLAYING',
            GAME_OVER: 'GAME_OVER'
        };
        let currentGameState = GameState.START_SCREEN;

        // DOM Elements
        const startScreen = document.getElementById('start-screen');
        const endScreen = document.getElementById('end-screen');
        const nameInputs = [
            document.getElementById('name1'), document.getElementById('name2'),
            document.getElementById('name3'), document.getElementById('name4'),
            document.getElementById('name5'),
        ];
        const startGameBtn = document.getElementById('start-game-btn');
        const restartGameBtn = document.getElementById('restart-game-btn');
        const shotNamesList = document.getElementById('shot-names-list');
        const crosshairElement = document.getElementById('crosshair');
        const nameNotificationElement = document.getElementById('name-notification');

        // Game Variables
        let namesSet = [];
        let shotNamesOrder = [];
        const MAX_NAMES = 5;

        // Three.js Variables
        let scene, camera, renderer, raycaster;
        const mouse = new THREE.Vector2(); // Normalized for Three.js
        let trees = [];
        let activeRabbit = null;
        let animationFrameId = null; // To control animation loop

        // Cannon.js Variables
        let world, groundPhysMaterial, rabbitPhysMaterial, treePhysMaterial;
        
        // Audio Context
        let audioCtx;
        let masterGain;
        let ambientSoundSource = null;

        const RABBIT_Y_POSITION = 0.35; 
        const MEADOW_SIZE = 80;
        const NUM_TREES = 20;
        const clock = new THREE.Clock(); 


        function init() {
            setupUIListeners();
            initAudio(); 
            checkStartButtonState(); 
        }

        function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.3; 
                masterGain.connect(audioCtx.destination);
            } catch (e) {
                console.warn('Web Audio API is not supported. Sound will be disabled.');
                audioCtx = null; 
            }
        }
        
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, MEADOW_SIZE * 0.4, MEADOW_SIZE * 0.9);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 15); 
            camera.lookAt(0, 1, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -MEADOW_SIZE / 2;
            directionalLight.shadow.camera.right = MEADOW_SIZE / 2;
            directionalLight.shadow.camera.top = MEADOW_SIZE / 2;
            directionalLight.shadow.camera.bottom = -MEADOW_SIZE / 2;
            scene.add(directionalLight);
        }

        function initPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();

            groundPhysMaterial = new CANNON.Material("groundMaterial");
            rabbitPhysMaterial = new CANNON.Material("rabbitMaterial");
            treePhysMaterial = new CANNON.Material("treeMaterial");

            world.addContactMaterial(new CANNON.ContactMaterial(groundPhysMaterial, rabbitPhysMaterial, { friction: 0.8, restitution: 0.1 }));
            world.addContactMaterial(new CANNON.ContactMaterial(treePhysMaterial, rabbitPhysMaterial, { friction: 0.5, restitution: 0.3 }));

            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0, material: groundPhysMaterial });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI / 2);
            world.addBody(groundBody);
        }

        function setupUIListeners() {
            nameInputs.forEach(input => input.addEventListener('input', checkStartButtonState));
            startGameBtn.addEventListener('click', startGame);
            restartGameBtn.addEventListener('click', restartGame);
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('click', onMouseClick, false);
        }

        function checkStartButtonState() {
            const currentNames = nameInputs.map(input => input.value.trim());
            const filledNames = currentNames.filter(name => name !== "");
            const uniqueNames = new Set(filledNames.map(name => name.toLowerCase()));
            startGameBtn.disabled = !(filledNames.length === MAX_NAMES && uniqueNames.size === MAX_NAMES);
        }

        function startGame() {
            namesSet = nameInputs.map(input => input.value.trim());
            shotNamesOrder = [];
            
            gsap.to(startScreen, { opacity: 0, duration: 0.5, onComplete: () => {
                startScreen.style.display = 'none';
                currentGameState = GameState.PLAYING;
                crosshairElement.style.display = 'block';
                document.body.style.cursor = 'none';
                if (!scene) { 
                    initThree();
                    initPhysics(); 
                    createProceduralEnvironment();
                } else { 
                    trees.forEach(tree => {
                        scene.remove(tree);
                        if (tree.userData.physicsBody) world.removeBody(tree.userData.physicsBody);
                    });
                    trees = [];
                    createProceduralEnvironment(); // Re-create for variation on restart
                }
                if (ambientSoundSource) ambientSoundSource.stop();
                ambientSoundSource = playProceduralSound('wind', { volume: 0.02, loop: true });
                spawnRabbit();
                if (!animationFrameId) animate(); // Start render loop if not already running
            }});
        }

        function endGame() {
            currentGameState = GameState.GAME_OVER;
            crosshairElement.style.display = 'none';
            document.body.style.cursor = 'default'; 
            if (activeRabbit) {
                if (activeRabbit.timeline) activeRabbit.timeline.kill();
                scene.remove(activeRabbit.mesh);
                if(activeRabbit.mesh.userData.physicsBody && world.bodies.includes(activeRabbit.mesh.userData.physicsBody)) {
                     world.removeBody(activeRabbit.mesh.userData.physicsBody);
                }
                activeRabbit = null;
            }
            if (ambientSoundSource) {
                ambientSoundSource.stop();
                ambientSoundSource = null;
            }
            playProceduralSound('celebrate', { volume: 0.4 });

            shotNamesList.innerHTML = ''; 
            shotNamesOrder.forEach(name => {
                const li = document.createElement('li');
                li.textContent = name;
                shotNamesList.appendChild(li);
            });

            endScreen.style.opacity = 0;
            endScreen.style.display = 'flex';
            gsap.to(endScreen, { opacity: 1, duration: 0.5 });
            // The animate() loop will stop itself based on currentGameState.
        }

        function restartGame() {
            gsap.to(endScreen, { opacity: 0, duration: 0.5, onComplete: () => {
                endScreen.style.display = 'none';
                namesSet = [];
                shotNamesOrder = [];
                nameInputs.forEach(input => input.value = '');
                checkStartButtonState();
                
                startScreen.style.opacity = 0;
                startScreen.style.display = 'flex';
                gsap.to(startScreen, { opacity: 1, duration: 0.5 });
                currentGameState = GameState.START_SCREEN;
            }});
        }

        function onWindowResize() {
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (currentGameState === GameState.PLAYING) {
                crosshairElement.style.left = event.clientX + 'px';
                crosshairElement.style.top = event.clientY + 'px';
            }
        }

        function onMouseClick() {
            if (currentGameState !== GameState.PLAYING || !activeRabbit || !activeRabbit.isPeeking) return;
            
            playProceduralSound('shoot', { volume: 0.5, filterFrequency: 1200, decay: 0.08 });

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(activeRabbit.mesh.userData.hitTarget, true); 

            if (intersects.length > 0) {
                handleRabbitHit();
            }
        }

        function createProceduralMeadowTexture(size = 256, repeat = 16) {
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const baseGreen = Math.floor(Math.random() * 20) + 70; 
            ctx.fillStyle = `rgb(0, ${baseGreen}, 0)`;
            ctx.fillRect(0, 0, size, size);
            for (let i = 0; i < 1500; i++) {
                const x = Math.random() * size; const y = Math.random() * size;
                const radius = Math.random() * (size/25) + (size/60);
                const gOff = Math.floor(Math.random() * 30) - 15; 
                const rOff = Math.floor(Math.random() * 15); 
                ctx.fillStyle = `rgba(${rOff}, ${Math.max(0, Math.min(255, baseGreen + gOff))}, 0, ${Math.random()*0.25 + 0.05})`;
                ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(repeat, repeat);
            if (renderer) texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return texture;
        }
        
        function proceduralColor(rBase, gBase, bBase, variance = 0.1) {
            return new THREE.Color(
                Math.max(0, rBase + (Math.random() - 0.5) * variance * 2),
                Math.max(0, gBase + (Math.random() - 0.5) * variance * 2),
                Math.max(0, bBase + (Math.random() - 0.5) * variance * 2)
            );
        }

        function createProceduralTree() {
            const treeGroup = new THREE.Group();
            const trunkHeight = Math.random() * 3 + 4; 
            const trunkRadius = Math.random() * 0.3 + 0.4; 
            const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, Math.floor(Math.random()*3)+5); 
            const trunkMat = new THREE.MeshStandardMaterial({ color: proceduralColor(0.4, 0.25, 0.15, 0.05), roughness: 0.8, metalness: 0.1 });
            const trunkMesh = new THREE.Mesh(trunkGeo, trunkMat);
            trunkMesh.castShadow = true; trunkMesh.receiveShadow = true;
            trunkMesh.position.y = trunkHeight / 2;
            treeGroup.add(trunkMesh);

            const canopyYBase = trunkHeight;
            const numCanopyParts = Math.floor(Math.random() * 4) + 3; 
            const canopyColor = proceduralColor(0.1, 0.4, 0.1, 0.1); 
            for (let i = 0; i < numCanopyParts; i++) {
                const partRadius = Math.random() * 1.2 + 1.0; 
                let partGeo;
                const geoType = Math.random();
                if (geoType < 0.6) partGeo = new THREE.SphereGeometry(partRadius, Math.floor(Math.random()*3)+5, Math.floor(Math.random()*2)+4); 
                else if (geoType < 0.8) partGeo = new THREE.IcosahedronGeometry(partRadius, Math.random() > 0.5 ? 0:1); 
                else partGeo = new THREE.DodecahedronGeometry(partRadius, Math.random() > 0.5 ? 0:1);
                const partMat = new THREE.MeshStandardMaterial({ color: canopyColor, roughness: 0.7, metalness: 0.0 });
                const partMesh = new THREE.Mesh(partGeo, partMat);
                partMesh.position.set((Math.random() - 0.5) * partRadius * 1.2, canopyYBase + (Math.random() - 0.3) * partRadius * 0.8, (Math.random() - 0.5) * partRadius * 1.2);
                partMesh.castShadow = true; partMesh.receiveShadow = true;
                treeGroup.add(partMesh);
            }
            
            const treeShape = new CANNON.Cylinder(trunkRadius, trunkRadius, trunkHeight, 8);
            const treeBody = new CANNON.Body({ mass: 0, material: treePhysMaterial }); 
            treeBody.addShape(treeShape);
            treeGroup.userData.physicsBody = treeBody; 
            return treeGroup;
        }

        function createProceduralEnvironment() {
            const groundGeo = new THREE.PlaneGeometry(MEADOW_SIZE, MEADOW_SIZE, 32, 32);
            const groundMat = new THREE.MeshStandardMaterial({ map: createProceduralMeadowTexture(256, MEADOW_SIZE/6), roughness: 0.9, metalness: 0.0 });
            const groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2; groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            for (let i = 0; i < NUM_TREES; i++) {
                const tree = createProceduralTree();
                let validPosition = false; let attempt = 0;
                while(!validPosition && attempt < 20) {
                    tree.position.set((Math.random() - 0.5) * (MEADOW_SIZE * 0.85), 0, (Math.random() - 0.5) * (MEADOW_SIZE * 0.85));
                    let tooClose = (Math.abs(tree.position.x) > MEADOW_SIZE/2 - 5 || Math.abs(tree.position.z) > MEADOW_SIZE/2 - 5);
                    if (!tooClose) {
                        for(const otherTree of trees) { if (tree.position.distanceTo(otherTree.position) < 6) { tooClose = true; break; }}
                    }
                    if (!tooClose) validPosition = true; attempt++;
                }
                if (validPosition) {
                    scene.add(tree); trees.push(tree);
                    if (tree.userData.physicsBody) {
                        tree.userData.physicsBody.position.copy(tree.position);
                        // tree.children[0] is the trunkMesh. Its geometry.parameters.height is the full trunk height.
                        tree.userData.physicsBody.position.y += tree.children[0].geometry.parameters.height / 2; 
                        tree.userData.physicsBody.quaternion.copy(tree.quaternion);
                        world.addBody(tree.userData.physicsBody);
                    }
                }
            }
        }

        function createProceduralRabbit() {
            const rabbitGroup = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: proceduralColor(0.7, 0.65, 0.6, 0.1), roughness: 0.6, metalness: 0.1 });
            const bodyRadius = Math.random() * 0.15 + 0.25; 
            const bodyGeo = new THREE.SphereGeometry(bodyRadius, 8, 6); 
            const bodyMesh = new THREE.Mesh(bodyGeo, mat); bodyMesh.castShadow = true;
            rabbitGroup.add(bodyMesh);

            const headRadius = bodyRadius * (Math.random() * 0.2 + 0.6); 
            const headGeo = new THREE.SphereGeometry(headRadius, 6, 5);
            const headMesh = new THREE.Mesh(headGeo, mat);
            headMesh.position.set(0, bodyRadius * 0.7, bodyRadius * 0.2); headMesh.castShadow = true;
            bodyMesh.add(headMesh); rabbitGroup.userData.head = headMesh;

            const earLength = headRadius * (Math.random() * 0.8 + 1.2); 
            const earRadius = headRadius * (Math.random() * 0.1 + 0.15); 
            for (let i = 0; i < 2; i++) {
                const earGeo = (typeof THREE.CapsuleGeometry !== 'undefined') ? new THREE.CapsuleGeometry(earRadius, earLength, 4, 6) : new THREE.CylinderGeometry(earRadius, earRadius, earLength, 6);
                const earMesh = new THREE.Mesh(earGeo, mat); earMesh.castShadow = true;
                earMesh.position.set((i === 0 ? -1 : 1) * headRadius * 0.6, headRadius * 0.5 + earLength * 0.4, headRadius * 0.1);
                earMesh.rotation.x = -(Math.PI / 3) + (Math.random() - 0.5) * 0.3; 
                earMesh.rotation.z = (i === 0 ? 1 : -1) * (Math.PI / 10) * (Math.random() * 0.5 + 0.5); 
                headMesh.add(earMesh);
            }

            const hitTargetSize = bodyRadius * 2.5; 
            const hitTargetGeo = new THREE.BoxGeometry(hitTargetSize, hitTargetSize, hitTargetSize);
            const hitTargetMat = new THREE.MeshBasicMaterial({ visible: false }); 
            const hitTargetMesh = new THREE.Mesh(hitTargetGeo, hitTargetMat);
            hitTargetMesh.position.y = bodyRadius * 0.5; 
            rabbitGroup.add(hitTargetMesh); rabbitGroup.userData.hitTarget = hitTargetMesh;
            
            const rabbitShape = new CANNON.Sphere(bodyRadius * 1.1); 
            const physicsBody = new CANNON.Body({ mass: 0.5, material: rabbitPhysMaterial, position: new CANNON.Vec3(0, RABBIT_Y_POSITION, 0) });
            physicsBody.addShape(rabbitShape);
            physicsBody.allowSleep = true; physicsBody.sleepSpeedLimit = 0.2; physicsBody.sleepTimeLimit = 1; 
            rabbitGroup.userData.physicsBody = physicsBody;
            return rabbitGroup;
        }

        function spawnRabbit() {
            if (activeRabbit || namesSet.length === 0) return;
            if (trees.length === 0) { console.warn("No trees to spawn rabbit from."); return; }

            const rabbitMesh = createProceduralRabbit();
            rabbitMesh.position.y = RABBIT_Y_POSITION;
            
            const treeIndex = Math.floor(Math.random() * trees.length);
            const spawnTree = trees[treeIndex];
            const trunkRadius = spawnTree.children[0].geometry.parameters.radiusTop || 0.5;
            
            const treePos = spawnTree.position;
            const dirToCamera = new THREE.Vector3().subVectors(camera.position, treePos).normalize();
            dirToCamera.y = 0; dirToCamera.normalize();
            const perpendicularDir = new THREE.Vector3(-dirToCamera.z, 0, dirToCamera.x); 
            const sideOffset = (Math.random() < 0.5 ? 1 : -1) * (trunkRadius + 0.6);
            
            const hiddenPos = new THREE.Vector3(
                treePos.x + perpendicularDir.x * sideOffset * 0.5 + dirToCamera.x * 0.5, 
                RABBIT_Y_POSITION,
                treePos.z + perpendicularDir.z * sideOffset * 0.5 + dirToCamera.z * 0.5
            );
            const peekPos = new THREE.Vector3(
                treePos.x + perpendicularDir.x * sideOffset,
                RABBIT_Y_POSITION,
                treePos.z + perpendicularDir.z * sideOffset
            );

            rabbitMesh.position.copy(hiddenPos);
            rabbitMesh.lookAt(new THREE.Vector3(camera.position.x, RABBIT_Y_POSITION, camera.position.z)); 
            scene.add(rabbitMesh);
            
            activeRabbit = { mesh: rabbitMesh, isPeeking: false, isHit: false, timeline: gsap.timeline() };

            const peekAnimDuration = Math.random() * 0.4 + 0.3;
            activeRabbit.timeline.to(rabbitMesh.position, {
                x: peekPos.x, y: peekPos.y, z: peekPos.z, duration: peekAnimDuration, 
                ease: "power1.out",
                onStart: () => { playProceduralSound('appear', { volume: 0.25, freq1: 600, freq2: 800, duration: 0.15 }); }
            })
            .set(activeRabbit, { isPeeking: true }); 

            const headWiggleDuration = 0.5; 
            activeRabbit.timeline.to(rabbitMesh.userData.head.rotation, {
                y: (Math.random() - 0.5) * 0.4, duration: headWiggleDuration / 2,
                yoyo: true, repeat: 1, ease: "sine.inOut"
            });

            const hopHeight = 0.25;
            const hopDurationMain = 0.20; 
            const numHops = Math.floor(Math.random() * 2) + 2; 

            for (let i = 0; i < numHops; i++) {
                activeRabbit.timeline
                    .to(rabbitMesh.position, { 
                        y: RABBIT_Y_POSITION + hopHeight, 
                        duration: hopDurationMain * 0.8, 
                        ease: "power1.out" 
                    }, i === 0 ? ">-=0.1" : ">+0.05") 
                    .to(rabbitMesh.rotation, { 
                        x: -Math.PI / 18, 
                        duration: hopDurationMain * 0.7, 
                        ease: "power1.out" 
                    }, "<") 
                    .to(rabbitMesh.position, { 
                        y: RABBIT_Y_POSITION, 
                        duration: hopDurationMain, 
                        ease: "bounce.out", 
                        onComplete: () => {
                            playProceduralSound('hopThump', { volume: 0.15, freq: 60, duration: 0.06, decay: 0.05 });
                        }
                    }) 
                    .to(rabbitMesh.rotation, { 
                        x: 0, 
                        duration: hopDurationMain * 0.9, 
                        ease: "power1.in" 
                    }, "<+=0.03"); 
            }
            
            activeRabbit.timeline.to(rabbitMesh.position, {
                x: hiddenPos.x, y: hiddenPos.y, z: hiddenPos.z, duration: Math.random() * 0.3 + 0.2, 
                ease: "power1.in",
                delay: 0.3, 
                onStart: () => { activeRabbit.isPeeking = false; } 
            })
            .call(() => { 
                if (activeRabbit && !activeRabbit.isHit) { 
                    scene.remove(rabbitMesh); activeRabbit = null;
                    if (namesSet.length > 0) { setTimeout(spawnRabbit, Math.random() * 1500 + 1000); } 
                    else { endGame(); }
                }
            });
        }

        function handleRabbitHit() {
            if (!activeRabbit || activeRabbit.isHit) return;
            activeRabbit.isHit = true; activeRabbit.isPeeking = false; 
            if (activeRabbit.timeline) activeRabbit.timeline.kill(); 

            playProceduralSound('hit', { volume: 0.4, startFreq: 300, endFreq: 80, duration: 0.4 });

            const rabbitMesh = activeRabbit.mesh;
            const physicsBody = rabbitMesh.userData.physicsBody;
            physicsBody.position.copy(rabbitMesh.position);
            physicsBody.quaternion.copy(rabbitMesh.quaternion);
            if (!world.bodies.includes(physicsBody)) { // Add only if not already added (e.g. by multiple quick hits)
                world.addBody(physicsBody);
            }
            physicsBody.wakeUp();

            const impulseStrength = 1.5;
            const randomForce = new CANNON.Vec3((Math.random() - 0.5) * impulseStrength, Math.random() * impulseStrength * 0.5, (Math.random() - 0.5) * impulseStrength);
            const worldPoint = new CANNON.Vec3(); 
            physicsBody.pointToWorldFrame(new CANNON.Vec3(0, rabbitMesh.children[0].geometry.parameters.radius * 0.5, 0), worldPoint);
            physicsBody.applyImpulse(randomForce, worldPoint);
            
            activeRabbit.isFalling = true;

            const shotName = namesSet.shift(); 
            shotNamesOrder.push(shotName);
            nameNotificationElement.textContent = shotName;
            gsap.fromTo(nameNotificationElement, 
                { y: "-100%", opacity: 0, display: 'block' }, 
                { y: "0%", opacity: 1, duration: 0.4, ease: "back.out(1.7)", 
                  onComplete: () => gsap.to(nameNotificationElement, { opacity: 0, duration: 0.3, delay: 1, onComplete: () => nameNotificationElement.style.display = 'none' })
                }
            );
            
            setTimeout(() => {
                if (activeRabbit && activeRabbit.mesh === rabbitMesh) { 
                    scene.remove(rabbitMesh); 
                    if (world.bodies.includes(physicsBody)) world.removeBody(physicsBody); 
                    activeRabbit = null;
                }
                if (namesSet.length > 0) { spawnRabbit(); } 
                else { endGame(); }
            }, 2000); 
        }

        function playProceduralSound(type, params = {}) {
            if (!audioCtx) return null;
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = params.volume !== undefined ? params.volume : 0.5;
            gainNode.connect(masterGain);
            let sourceNode; 
            const duration = params.duration || 0.2;
            const now = audioCtx.currentTime;

            switch (type) {
                case 'shoot': {
                    const noiseSource = audioCtx.createBufferSource();
                    const bufferSize = audioCtx.sampleRate * 0.05;
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    noiseSource.buffer = buffer;
                    const envelope = audioCtx.createGain();
                    envelope.gain.setValueAtTime(0, now);
                    envelope.gain.linearRampToValueAtTime(1, now + 0.005); 
                    envelope.gain.exponentialRampToValueAtTime(0.01, now + (params.decay || 0.08)); 
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'bandpass'; filter.frequency.value = params.filterFrequency || 1200; filter.Q.value = params.Q || 3;
                    noiseSource.connect(envelope); envelope.connect(filter); filter.connect(gainNode);
                    noiseSource.start(now); noiseSource.stop(now + (params.decay || 0.08) + 0.02);
                    break;
                }
                case 'hit': { 
                    const osc = audioCtx.createOscillator(); osc.type = 'sine';
                    osc.frequency.setValueAtTime(params.startFreq || 350, now);
                    osc.frequency.exponentialRampToValueAtTime(params.endFreq || 80, now + duration);
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(params.volume || 0.4, now + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    osc.connect(gainNode); osc.start(now); osc.stop(now + duration);
                    break;
                }
                case 'appear': { 
                    const osc = audioCtx.createOscillator(); osc.type = 'triangle';
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(params.volume || 0.25, now + 0.01);
                    gainNode.gain.setValueAtTime(params.volume || 0.25, now + duration * 0.4); 
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    osc.frequency.setValueAtTime(params.freq1 || 700, now);
                    osc.frequency.setValueAtTime(params.freq2 || 900, now + duration * 0.5);
                    osc.connect(gainNode); osc.start(now); osc.stop(now + duration);
                    break;
                }
                case 'celebrate': { 
                    const osc = audioCtx.createOscillator(); osc.type = 'sawtooth';
                    const baseFreq = 200; const steps = [0, 4, 7, 12, 7, 4, 0]; 
                    const noteDur = 0.12; gainNode.gain.setValueAtTime(params.volume || 0.3, now);
                    steps.forEach((step, index) => osc.frequency.setValueAtTime(baseFreq * Math.pow(2, step/12), now + index * noteDur));
                    osc.connect(gainNode); osc.start(now); osc.stop(now + steps.length * noteDur);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + steps.length * noteDur + 0.2);
                    break;
                }
                case 'wind': { 
                    const bufferSize = audioCtx.sampleRate * 5;
                    const buffer = audioCtx.createBuffer(2, bufferSize, audioCtx.sampleRate); 
                    for (let ch = 0; ch < 2; ch++) { const data = buffer.getChannelData(ch); for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1; }
                    sourceNode = audioCtx.createBufferSource(); sourceNode.buffer = buffer; sourceNode.loop = true;
                    const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(80, now); filter.Q.value = 1;
                    const lfo = audioCtx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.1; 
                    const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 30; 
                    lfo.connect(lfoGain); lfoGain.connect(filter.frequency);
                    gainNode.gain.value = params.volume || 0.03;
                    sourceNode.connect(filter); filter.connect(gainNode); sourceNode.start(now); lfo.start(now);
                    break;
                }
                case 'hopThump': {
                    const osc = audioCtx.createOscillator(); osc.type = 'sine'; 
                    const attack = 0.005; const decay = params.decay || 0.05; const freq = params.freq || 60;
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(params.volume || 0.15, now + attack);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration); // Use main duration for overall sound length
                    osc.frequency.setValueAtTime(freq, now);
                    osc.frequency.linearRampToValueAtTime(freq * 0.8, now + duration * 0.7); 
                    osc.connect(gainNode); osc.start(now); osc.stop(now + duration);
                    break;
                }
            }
            return sourceNode;
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            if (currentGameState === GameState.START_SCREEN && !(activeRabbit && activeRabbit.isFalling)) {
                // If on start screen AND no rabbit is falling, we can effectively pause rendering by not processing further.
                // However, if lil-gui or other always-on UI is present, might want to render. For this game, it's fine.
                // To truly stop the loop: cancelAnimationFrame(animationFrameId); animationFrameId = null; return;
                // For now, just returning is okay as the next call will also hit this and return.
                // To be cleaner and ensure it stops:
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                return; 
            }

            const deltaTime = clock.getDelta(); 
            const fixedTimeStep = 1 / 60;
            const maxSubSteps = 3;

            if (world && (currentGameState === GameState.PLAYING || (activeRabbit && activeRabbit.isFalling))) {
                 world.step(fixedTimeStep, deltaTime, maxSubSteps);
                if (activeRabbit && activeRabbit.isFalling && activeRabbit.mesh.userData.physicsBody) {
                    activeRabbit.mesh.position.copy(activeRabbit.mesh.userData.physicsBody.position);
                    activeRabbit.mesh.quaternion.copy(activeRabbit.mesh.userData.physicsBody.quaternion);
                }
            }
            if(renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        init();
    </script>
</body>
</html>